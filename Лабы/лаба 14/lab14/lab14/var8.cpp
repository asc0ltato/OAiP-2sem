//4. В соответствии со своим вариантом написать программу для сортировок массивов указанными в таблице методами.Исходные массивы заполняются случайными числами. Определить зависимость времени
//выполнения алгоритмов от количества элементов для каждого из алгоритмов.Выполнить моделирование для массивов размером 1000, 2000, 3000, 4000, 5000 (в зависимости от быстродействия компьютера 
//размеры массивов можно увеличивать). Произвести сравнение эффективности алгоритмов(построить график в приложении Excel).
//8. Сортировка Хоара, пирамидальная сортировка, сортировка слиянием

#include <iostream>
#include <ctime>
using namespace std;

//Функция, которая реализует быструю сортировку(Хоара). Массив делится на две части относительно некоторого значения, называемого медианой. В левой части числа меньше медианы, в правой – больше.
int getHoarBorder(int A[], int sm, int em)
{
	//A[] – исходный массив чисел, sm – индекс первого элемента массива, em – индекс последнего (последний элемент правой части)
	int i = sm - 1, j = em + 1;
	int brd = A[sm]; //грань Хаора (границы разделения)
	int buf; //временная переменная для обмена значениями
	while (i < j) //проходы по массиву влево и вправо, чтобы найти элементы, которые нужно поменять местами
	{
		while (A[--j] > brd);
		while (A[++i] < brd);
		if (i < j) //меняем местами A[i] и A[j]
		{
			buf = A[j];
			A[j] = A[i];
			A[i] = buf;
		};
	}
	return j;
}
	
//Функция, которая рекурсивно вызывает getHoarBorder() для разделения массива на две части и сортирует их отдельно
int* sortHoar(int A[], int sm, int em)
{
	if (sm < em) //если нет, то массив уже отсортирован
	{
		int hb = getHoarBorder(A, sm, em); //находим границу между левой и правой частью
		sortHoar(A, sm, hb); //для левой
		sortHoar(A, hb + 1, em); //для правой
	}
	return A;
};
//------------------------------------------------------
//Функция, которая преобразует массив в бинарную кучу	
void heapify(int A[], int pos, int n)
{
	int t, tm;
	while (2 * pos + 1 < n)  //проверка что у элемента pos есть потомки
	{
		t = 2 * pos + 1; //левый потомок
		if (2 * pos + 2 < n && A[2 * pos + 2] >= A[t]) //если есть правый потомок
			t = 2 * pos + 2; //обновляем t
		if (A[pos] < A[t])
		{
			tm = A[pos]; //меняем местами
			A[pos] = A[t];
			A[t] = tm;
			pos = t;
		}
		else break;
	}
}

//Функция, которая вызывает heapify() для каждого элемента массива, чтобы превратить его в бинарную кучу, а затем последовательно извлекает максимальный элемент и переносит его в конец массива, постепенно уменьшая размер кучи
void piramSort(int A[], int n)
{
	for (int i = n - 1; i >= 0; i--) //перебор элементов с конца
		heapify(A, i, n);
	while (n > 0) //сортируем А и повторяем, пока размер n не станет равен 0
	{
		int tm = A[0];
		A[0] = A[n - 1];
		A[n - 1] = tm;
		n--;
		heapify(A, 0, n); //для корня дерева
	}
}
//--------------------------------------------------
//Функция, которая сортирует массив вставкой, перемещая элементы справа налево, чтобы сделать место для нового элемента, который вставляется на правильное место
void insOrd(int m[], int sm, int em, int e)
{  // m[] - массив чисел; sm - индекс 1-ого элемента левой части; cm - индекс
  //последн. элемента левой части; em - индекс последн. элемента правой части
	int buf;
	int i = sm;
	while (i <= em && m[i] < e)
	{
		if (i - 1 >= sm)
			m[i - 1] = m[i];
		i++;
	}  m[i - 1] = e;
}

//Функция, которая сливает два упорядоченных массива в один, используя insOrd(), чтобы вставить элементы из первого массива в правильное место во втором массиве
int* merge(int m[], int sm, int cm, int em)
{
	for (int i = 0; i <= sm; i++)
	{
		if (m[i] > m[cm + 1])
		{
			int buf = m[i];
			m[i] = m[cm + 1];
			insOrd(m, cm + 1, em, buf);
		}
	}
	return m;
}

//Функция, которая рекурсивно вызывает саму себя, чтобы разделить массив на две части и затем сливает их в отсортированный массив, используя merge()
int* sortMerge(int m[], int lm, int sm = 0)
{
	if (lm > 1)
	{
		sortMerge(m, lm / 2, sm);
		sortMerge(m, lm - lm / 2, sm + lm / 2);
		merge(m, sm, sm + lm / 2 - 1, sm + lm - 1);
	};
	return m;
}

//Функция, которая генерирует случайные числа, используя текущее время для установки seed для генератора псевдослучайных чисел
int getRandKey(int reg = 0)    
{
	if (reg > 0)
		srand((unsigned)time(NULL));
	int rmin = 0;
	int rmax = 100000;
	return (int)(((double)rand() / (double)RAND_MAX) * (rmax - rmin) + rmin);
}

int main()
{
	setlocale(LC_CTYPE, "Russian");
	const int N = 5000;  //максимальный размер массива
	int k[N], f[N];  // объявление двух массивов размера N: k и f
	clock_t  t1, t2;
	getRandKey(1);
	for (int i = 0; i < N; i++)  //инициализация массива f случайными числами с помощью функции getRandKey(0)
		f[i] = getRandKey(0);
	for (int n = 1000; n <= N; n += 1000) // c 1000 до 5000
	{
		cout << "n = " << n << endl;

		cout << "Сортировка Хаора(быстрая): ";
		memcpy(k, f, n * sizeof(int));
		t1 = clock();
		sortHoar(k, 0, n - 1);
		t2 = clock();
		cout << "Прошло " << t2 - t1 << " тактов времени" << endl;
			 
		cout << "Пирамидная сортировка: ";
		memcpy(k, f, n * sizeof(int));
		t1 = clock();
		piramSort(k, n);
		t2 = clock();
		cout << "Прошло " << t2 - t1 << " тактов времени" << endl;

		cout << "Сортировка слиянием: ";
		memcpy(k, f, n * sizeof(int));
		t1 = clock();
		sortMerge(k, n);
		t2 = clock();
		cout << "Прошло " << t2 - t1 << " тактов времени" << endl << endl;
	}
	return 0;
}